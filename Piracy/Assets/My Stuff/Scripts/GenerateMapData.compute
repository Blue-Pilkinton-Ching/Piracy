// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct MapPoint
{
    float3 color;
    float height;
    float isSpawnPoint;
};

RWStructuredBuffer<MapPoint> mapPoints;

float chunkWidth;
float2 chunkPosition;

float rand(float2 uv)
{
    return frac(sin(dot(uv, float2(12.98457, 78.2334))) * 43758.5453);
}

inline float2 unity_voronoi_noise_randomVector (float2 UV, float offset)
{
    float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
    UV = frac(sin(mul(UV, m)) * 46839.32);
    return float2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5);
}

void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float softEdge, out float3 color)
{
    float2 g = floor(UV * CellDensity);
    float2 f = frac(UV * CellDensity);
    float3 res = float3(8.0, 0.0, 0.0);

    for(int y=-1; y<=1; y++)
    {
        for(int x=-1; x<=1; x++)
        {
            float2 lattice = float2(x,y);
            float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
            float d = distance(lattice + offset, f);
            if(d < res.x)
            {
                res = float3(d, offset.x, offset.y);

                softEdge = res.x;
                color = rand(offset);
            }
        }
    }
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    MapPoint mapPoint;

    float softEdge;
    float3 color;

    float2 UV = float2((id.x / chunkWidth) + chunkPosition.x, (id.y / chunkWidth) + chunkPosition.y);

    Unity_Voronoi_float(UV, 1.1, 11, softEdge, color);

    float3 biome = (1 - smoothstep(0, 0.4, softEdge)) * color;

    mapPoint.color = biome;

    mapPoint.height = 5;
    mapPoint.isSpawnPoint = 1;

    uint index = id.y * chunkWidth + id.x;

    mapPoints[index] = mapPoint;
}

